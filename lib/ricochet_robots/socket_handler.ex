defmodule RicochetRobots.SocketHandler do
  @moduledoc """
  Controls the way a user interacts with a `Room` (e.g. chat) or a `Game` (e.g.
  making a move).

  The state for a socket handler is the unique player name.
  """

  require Logger
  alias RicochetRobots.{Player, Room, Game}

  defstruct player_name: nil

  @type t :: %{
          player_name: String.t()
        }

  @behaviour :cowboy_websocket
  @idle_timeout 90_000

  @impl true
  def init(request, _state) do
    state = %__MODULE__{player_name: Player.new(self())}

    Logger.info("New websocket connection initiated by \"#{state.player_name}\".")
    {:cowboy_websocket, request, state, %{idle_timeout: @idle_timeout}}
  end

  @impl true
  def websocket_init(state) do
    {:ok, state}
  end

  @doc """
  Take a websocket transmission and attempt to decode the JSON. If the
  transmission is valid, match the transmission against other more specific
  handlers. If invalid, return an error to the client.
  """
  @impl true
  def websocket_handle({:text, json}, state) do
    case Poison.decode!(json) do
      {:ok, payload} ->
        Logger.debug("Successfully decoded JSON transmission from \"#{state.player_name}\".")
        websocket_handle({:json, payload["action"], payload["content"]}, state)

      {:error, _} ->
        Logger.debug("Failed to decode JSON transmission from \"#{state.player_name}\".")
        {:reply, {:text, "Failed to decode JSON."}, state}
    end
  end

  @doc """
  Action: ping

  The client should periodically ping the server if no other transmissions have
  been sent over the socket. If no transmissions have been sent in the last 90
  seconds, the server will assume that the client has timed out and the socket
  will be closed. We respond with a pong.
  """
  @impl true
  def websocket_handle({:json, "ping", _content}, state) do
    Logger.debug("Received ping from \"#{state.player_name}\".")
    response = Poison.encode!(%{action: "ping", content: "pong"})
    {:reply, {:text, response}, state}
  end

  @doc """
  Action: create_room

  Players can create new rooms, the name of which will be autogenerated. They
  will be made the admin of the room and joined to the room.

  Options:
    player_limit: The player limit for the new room. By default, 8.
  """
  @impl true
  def websocket_handle({:json, "create_room", opts}, state) do
    room_name = Room.new(opts)
    Room.add_player(room_name, state.player_name)
    {:reply, {:text, "success"}, state}
  end

  @doc """
  Action: join_room

  Join an existing room if the room is not over the player limit. New player
  will need to wait to the start of the next game to play, but they will be
  able to participate in chat.
  """
  @impl true
  def websocket_handle({:json, "join_room", %{room_name: room_name}}, state) do
    Logger.debug("Attempting to add player \"#{state.player_name}\" to room \"#{room_name}\".")

    case Room.add_player(room_name, state.player_name) do
      :ok -> {:reply, {:text, "success"}, state}
      :error -> {:reply, {:text, "failure"}, state}
    end
  end

  @doc """
  Action: new_game

  Start a new game. Check to see if a game is currently in progress; if one
  is, then do not do anything. If no game is currently in progress, send out a
  new board, new robots, and new goals to players.
  # TODO: Enforce who can start a new game? Or log who started the game?
  """
  @impl true
  def websocket_handle({:json, "new_game", %{room_name: room_name}}, state) do
    case Game.new(room_name) do
      :ok ->
        Room.system_chat(room_name, "#{state.player.username} has started a new game!")
        {:reply, {:text, "success"}, state}

      :error ->
        {:reply, {:text, "failure"}, state}
    end
  end

  # TODO: ONLY send board, goals, robots to the new user
  @doc "new_user : need to send out user initialization info to client, and new user message, scoreboard to all users"
  @impl true
  def websocket_handle({:json, "create_user", _content}, state) do
    Logger.debug("[New user]: " <> state.player.username)

    # seperate message for client that just joined
    Room.system_chat(state.registry_key, "#{state.player.username} has joined the game.")

    Room.system_chat_to_player(
      state.registry_key,
      state[:player].username,
      "Welcome to Ricochet Robots, #{state[:player].username}!"
    )

    Room.broadcast_scoreboard(state.registry_key)

    Game.broadcast_visual_board()
    Game.broadcast_robots()
    Game.broadcast_goals()
    Game.broadcast_clock()

    # send out user initialization info to client
    response = Poison.encode!(%{content: state[:player], action: "update_user"})
    {:reply, {:text, response}, state}
  end

  @doc "new_chatline: need to send out new chatline to all users"
  @impl true
  def websocket_handle({:json, "update_chat", content}, state) do
    Room.player_chat(state.registry_key, state.player, content["msg"])

    {:reply, {:text, "success"}, state}
  end

  # TODO: Validate name against other users! Move to player.ex!
  @doc "update_user : need to send validated user info to 1 client and new scoreboard to all"
  @impl true
  def websocket_handle({:json, "update_user", content}, state) do
    Logger.debug("[Update user] " <> state[:player].username <> " --> " <> content["username"])

    old_user = state[:player]

    new_username =
      if String.trim(content["username"]) != "" do
        String.slice(String.trim(content["username"]), 0, 16)
      else
        old_user.username
      end

    new_color =
      if String.trim(content["color"]) != "" do
        String.trim(content["color"])
      else
        old_user.color
      end

    new_user = %{old_user | username: new_username, color: new_color}
    new_state = %{state | player: new_user}

    # send scoreboard to all
    Player.update(new_user)
    Room.broadcast_scoreboard(state.registry_key)

    # send client their new user info
    response = Poison.encode!(%{content: content, action: "update_user"})
    {:reply, {:text, response}, new_state}
  end

  # TODO: all
  @doc "submit_movelist : simulate the req. moves"
  @impl true
  def websocket_handle({:json, "submit_movelist", content}, state) do
    Logger.debug("[Move] " <> state[:player].username <> " --> ")

    new_robots = Game.move_robots(content, state.player.unique_key)
    response = Poison.encode!(%{content: new_robots, action: "update_robots"})
    {:reply, {:text, response}, state}
  end

  @doc "_ : handle all other JSON data with `action` as unknown."
  @impl true
  def websocket_handle({:json, action, _}, state) do
    Logger.debug("Unhandled action from client #{state.player_name}: " <> action)

    response = Poison.encode!(%{action: "error", message: "Unsupported action."})
    {:reply, {:text, response}, state}
  end

  @doc """
  Forward Elixir messages to client.
  """
  @impl true
  def websocket_info(info, state) do
    {:reply, {:text, info}, state}
  end

  # TODO: all
  @doc """
  Callback function for a terminated socket. Announce the player's
  parting, remove them from all their rooms, and broadcast the state change to
  all clients.
  """
  @impl true
  def terminate(_reason, _req, state) do
    state.rooms
    Room.system_chat(state.rooms, state.player_name <> " has left.")
    Room.remove_player(state.registry_key, state.player.unique_key)
    Room.broadcast_scoreboard(state.registry_key)
    :ok
  end
end
